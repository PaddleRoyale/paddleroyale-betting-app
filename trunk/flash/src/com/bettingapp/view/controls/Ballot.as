package com.bettingapp.view.controls{	import com.bettingapp.controller.events.BettingAppEvent;	import com.bettingapp.model.managers.EventManager;	import com.bettingapp.model.managers.ScreenManager;	import com.greensock.TweenMax;		import flash.display.MovieClip;	public class Ballot extends MovieClip	{		static public const RESET_PAGE:int   = 0;		static public const NEXT_PAGE:int = 1;		static public const PREV_PAGE:int = 2;		private const FADE_TIME:Number = 0.3;		private const MAX_ITEMS_PER_PAGE:int = 16;		private const VERT_SPACING:Number = 15;// vertical spacing between ballots items.		private var _candidates:Array = new Array();		private var _currentPage:int;		private var _numPages:int;		private var _currentFilter:String;		public function Ballot()		{			super();		}		public function reset():void		{			clearBallot();						// release what's held on to by each ballot button.			for each (var ballotButton:BallotButton in _candidates)			{				ballotButton.release();			}			_candidates.length = 0;		}		// Flash 11 has a method on the DisplayObject class to do this, we're compiling down to flash 10, so manually writing one.		private function clearBallot():void		{			if (numChildren != 0)			{				var childCount:int = numChildren;				while (childCount -- )				{					removeChildAt(childCount);				}			}		}		public override function set enabled($val:Boolean):void		{			if ($val)			{				EventManager.instance.addEventListener(BettingAppEvent.BUTTON_PRESSED, onButtonPressed);			}			else			{				EventManager.instance.removeEventListener(BettingAppEvent.BUTTON_PRESSED, onButtonPressed);			}			super.enabled = $val;		}		private function onButtonPressed($e:BettingAppEvent):void		{			for each (var candidate:BallotButton in _candidates)			{				if ($e.parameters.button == candidate)				{					var event:BettingAppEvent = new BettingAppEvent(BettingAppEvent.CANDIDATE_SELECTED);					event.parameters.candidate = candidate;					EventManager.instance.dispatchEvent(event);					break;				}			}		}		public function get candidates()		{			return _candidates;		}		public function doLayout($page:int = RESET_PAGE, $filter:String = ""):void		{			// small check, make sure we are not trying to page out of bounds, if so, nothing needs to be done.			if ((($page == Ballot.NEXT_PAGE) && (_currentPage >= _numPages)) ||			(($page == Ballot.PREV_PAGE) && (_currentPage <= 1)))			{				return;			}			// fade out what we're showing, so we can put in new values.			TweenMax.to(this, FADE_TIME, {alpha:0, onComplete:executeLayout, onCompleteParams:[$page, $filter]});		}		private function executeLayout($page:int, $filter:String):void		{			var offsetY:Number = 0;			var numRowItems:int = 0;			var offsetX:Number = x;			var filteredCandidates:Array = new Array();			var candidate:BallotButton;			if ($page == RESET_PAGE)			{				_currentFilter = $filter.toLowerCase();				trace("changing filter to: " + _currentFilter);			}			filteredCandidates.length = 0;			// first loop, filter out the candidates we want to display			for each (candidate in _candidates)			{				if ((_currentFilter.length == 0) || (candidate.label.toLowerCase().indexOf(_currentFilter) >= 0))				{					filteredCandidates.push(candidate);				}			}			// calculate start and end index based on what page is being requested to show.			var startIndex = 0;			var endIndex = 0;			switch ($page)			{				case NEXT_PAGE :// user desires next page in filtered set.					if (_currentPage < _numPages)					{						++_currentPage;						startIndex = (_currentPage - 1) * MAX_ITEMS_PER_PAGE;						endIndex = startIndex + MAX_ITEMS_PER_PAGE;					}					else					{						// don't need to update if we're already on first page.						return;					}					break;				case PREV_PAGE :// user desires prev page in filtered set.					if (_currentPage > 1)					{						--_currentPage;						startIndex = (_currentPage - 1) * MAX_ITEMS_PER_PAGE;						endIndex = startIndex + MAX_ITEMS_PER_PAGE;					}					else					{						// don't need to update if we're already on last page.						return;					}					break;				case RESET_PAGE :// resettting for newly requested record set.				default :					// reset paging info					_currentPage = 1;// always start at page 1					// see how many full pages we have.					_numPages = (filteredCandidates.length / MAX_ITEMS_PER_PAGE);					// determine any partial pages and add it on to our page total.					if ((filteredCandidates.length %  MAX_ITEMS_PER_PAGE) > 0)					{						++_numPages;					}					// reset start/end indeces.					startIndex = 0;					endIndex = MAX_ITEMS_PER_PAGE;					break;			}			// clear container.			clearBallot();			// we need to take into account any scale being applied to reference clip.			var appWidth:Number = ScreenManager.instance.appWidth;					for (var i:int = startIndex; i < endIndex; i++)			{				if (filteredCandidates[i])				{					candidate = filteredCandidates[i] as BallotButton;					// offset x based on column.					candidate.x = (numRowItems == 0) ? 0 : ( appWidth - candidate.width - (offsetX * 2));					candidate.y = offsetY;					addChild(candidate);					// see if we need to adjust y					if (++numRowItems == 2)					{						// adjust y offset						offsetY += (candidate.height + VERT_SPACING);						numRowItems = 0;					}				}			}			// tell the app the updated paging parameters in case there's any UI that needs updating.			var event:BettingAppEvent = new BettingAppEvent(BettingAppEvent.UPDATE_PAGING_INFO);			event.parameters.numPages = _numPages;			event.parameters.currentPage = _currentPage;			event.parameters.startIndex = startIndex;			event.parameters.endIndex = endIndex;			EventManager.instance.dispatchEvent(event);			// fade in new layout.;			TweenMax.to(this, FADE_TIME, {alpha:1});		}	}}